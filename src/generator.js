/**
 * OpenAPI CRUD Generator
 * Generates OpenAPI specifications from JSON Schema files
 */

import fs from 'fs';
import path from 'path';

/**
 * Load all JSON schemas from a directory
 * @param {string} schemasDir - Path to schemas directory
 * @returns {Array} Array of schema objects with metadata
 */
export function loadSchemas(schemasDir) {
  const files = fs.readdirSync(schemasDir)
    .filter(f => f.endsWith('.schema.json'));

  const schemas = [];

  for (const file of files) {
    const filePath = path.join(schemasDir, file);
    const content = fs.readFileSync(filePath, 'utf-8');
    const schema = JSON.parse(content);

    schemas.push({
      fileName: file,
      schema
    });
  }

  return schemas;
}

/**
 * Convert file-based $ref to OpenAPI component reference
 * @param {Object} obj - Object to process
 * @param {Map} schemaMap - Map of filename to schema title
 * @returns {Object} Processed object
 */
function convertRefs(obj, schemaMap) {
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }

  if (Array.isArray(obj)) {
    return obj.map(item => convertRefs(item, schemaMap));
  }

  const result = {};

  for (const [key, value] of Object.entries(obj)) {
    if (key === '$ref' && typeof value === 'string' && value.endsWith('.schema.json')) {
      // Convert file reference to OpenAPI component reference
      const schemaTitle = schemaMap.get(value);
      if (schemaTitle) {
        result[key] = `#/components/schemas/${schemaTitle}`;
      } else {
        result[key] = value; // Keep as-is if not found
      }
    } else if (key === '$schema') {
      // Skip $schema - not valid in OpenAPI component schemas
      continue;
    } else {
      result[key] = convertRefs(value, schemaMap);
    }
  }

  return result;
}

/**
 * Generate OpenAPI specification from configuration and schemas
 * @param {Object} config - Configuration object
 * @returns {Object} OpenAPI specification object
 */
export async function generateOpenAPI(config) {
  const {
    title = 'Generated API',
    version = '1.0.0',
    description = 'API generated by OpenAPI CRUD Generator',
    baseUrl = 'http://localhost:3000',
    schemasDir
  } = config;

  if (!schemasDir) {
    throw new Error('schemasDir is required in configuration');
  }

  // Load all schemas
  const schemaFiles = loadSchemas(schemasDir);

  // Create map of filename to schema title for $ref conversion
  const schemaMap = new Map();
  for (const { fileName, schema } of schemaFiles) {
    schemaMap.set(fileName, schema.title);
  }

  const spec = {
    openapi: '3.0.0',
    info: {
      title,
      version,
      description
    },
    servers: [
      {
        url: baseUrl,
        description: 'API Server'
      }
    ],
    paths: {},
    components: {
      schemas: {},
      responses: {
        NotFound: {
          description: 'Resource not found',
          content: {
            'application/json': {
              schema: {
                type: 'object',
                properties: {
                  error: { type: 'string' },
                  message: { type: 'string' }
                }
              }
            }
          }
        },
        ValidationError: {
          description: 'Validation error',
          content: {
            'application/json': {
              schema: {
                type: 'object',
                properties: {
                  error: { type: 'string' },
                  details: { type: 'array', items: { type: 'object' } }
                }
              }
            }
          }
        }
      }
    }
  };

  // Process each schema
  for (const { schema } of schemaFiles) {
    const schemaTitle = schema.title;

    // Convert refs and add to components
    const convertedSchema = convertRefs(schema, schemaMap);
    spec.components.schemas[schemaTitle] = convertedSchema;

    // Generate CRUD paths for this schema
    generateEndpointPaths(spec, schema);
  }

  return spec;
}

/**
 * Generate paths for a single schema/endpoint
 */
function generateEndpointPaths(spec, schema) {
  const {
    title,
    'x-plural': plural,
    'x-camel': camel,
    'x-camel-plural': camelPlural
  } = schema;

  if (!plural || !camelPlural) {
    console.warn(`Schema "${title}" missing x-plural or x-camel-plural, skipping path generation`);
    return;
  }

  const basePath = `/${camelPlural}`;
  const itemPath = `${basePath}/{id}`;

  spec.paths[basePath] = spec.paths[basePath] || {};
  spec.paths[itemPath] = spec.paths[itemPath] || {};

  // LIST operation - GET /resources
  spec.paths[basePath].get = {
    summary: `List all ${camelPlural}`,
    tags: [plural],
    parameters: [
      {
        name: 'page',
        in: 'query',
        schema: { type: 'integer', default: 1 },
        description: 'Page number'
      },
      {
        name: 'limit',
        in: 'query',
        schema: { type: 'integer', default: 10 },
        description: 'Items per page'
      }
    ],
    responses: {
      '200': {
        description: `List of ${camelPlural}`,
        content: {
          'application/json': {
            schema: {
              type: 'object',
              properties: {
                data: {
                  type: 'array',
                  items: { $ref: `#/components/schemas/${title}` }
                },
                total: { type: 'integer' },
                page: { type: 'integer' },
                limit: { type: 'integer' }
              }
            }
          }
        }
      }
    }
  };

  // CREATE operation - POST /resources
  spec.paths[basePath].post = {
    summary: `Create a new ${camel}`,
    tags: [plural],
    requestBody: {
      required: true,
      content: {
        'application/json': {
          schema: { $ref: `#/components/schemas/${title}` }
        }
      }
    },
    responses: {
      '201': {
        description: `${title} created successfully`,
        content: {
          'application/json': {
            schema: { $ref: `#/components/schemas/${title}` }
          }
        }
      },
      '400': {
        $ref: '#/components/responses/ValidationError'
      }
    }
  };

  // GET operation - GET /resources/{id}
  spec.paths[itemPath].get = {
    summary: `Get a ${camel} by ID`,
    tags: [plural],
    parameters: [
      {
        name: 'id',
        in: 'path',
        required: true,
        schema: { type: 'string' },
        description: `${title} ID`
      }
    ],
    responses: {
      '200': {
        description: `${title} details`,
        content: {
          'application/json': {
            schema: { $ref: `#/components/schemas/${title}` }
          }
        }
      },
      '404': {
        $ref: '#/components/responses/NotFound'
      }
    }
  };

  // UPDATE operation - PUT /resources/{id}
  spec.paths[itemPath].put = {
    summary: `Update a ${camel}`,
    tags: [plural],
    parameters: [
      {
        name: 'id',
        in: 'path',
        required: true,
        schema: { type: 'string' },
        description: `${title} ID`
      }
    ],
    requestBody: {
      required: true,
      content: {
        'application/json': {
          schema: { $ref: `#/components/schemas/${title}` }
        }
      }
    },
    responses: {
      '200': {
        description: `${title} updated successfully`,
        content: {
          'application/json': {
            schema: { $ref: `#/components/schemas/${title}` }
          }
        }
      },
      '400': {
        $ref: '#/components/responses/ValidationError'
      },
      '404': {
        $ref: '#/components/responses/NotFound'
      }
    }
  };

  // DELETE operation - DELETE /resources/{id}
  spec.paths[itemPath].delete = {
    summary: `Delete a ${camel}`,
    tags: [plural],
    parameters: [
      {
        name: 'id',
        in: 'path',
        required: true,
        schema: { type: 'string' },
        description: `${title} ID`
      }
    ],
    responses: {
      '204': {
        description: `${title} deleted successfully`
      },
      '404': {
        $ref: '#/components/responses/NotFound'
      }
    }
  };
}

export default { generateOpenAPI, loadSchemas };
