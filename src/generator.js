/**
 * OpenAPI CRUD Generator
 * Generates OpenAPI specifications from simple endpoint definitions
 */

/**
 * Map JavaScript types to OpenAPI types
 */
const TYPE_MAPPING = {
  string: { type: 'string' },
  number: { type: 'number' },
  integer: { type: 'integer' },
  boolean: { type: 'boolean' },
  date: { type: 'string', format: 'date' },
  datetime: { type: 'string', format: 'date-time' },
  email: { type: 'string', format: 'email' },
  uuid: { type: 'string', format: 'uuid' },
  array: { type: 'array' },
  object: { type: 'object' }
};

/**
 * Generate OpenAPI specification from endpoint definitions
 * @param {Object} config - Configuration object
 * @param {string} config.title - API title
 * @param {string} config.version - API version
 * @param {string} config.description - API description
 * @param {string} config.baseUrl - Base URL for the API
 * @param {Array} config.endpoints - Array of endpoint definitions
 * @returns {Object} OpenAPI specification object
 */
export function generateOpenAPI(config) {
  const {
    title = 'Generated API',
    version = '1.0.0',
    description = 'API generated by OpenAPI CRUD Generator',
    baseUrl = 'http://localhost:3000',
    endpoints = []
  } = config;

  const spec = {
    openapi: '3.0.0',
    info: {
      title,
      version,
      description
    },
    servers: [
      {
        url: baseUrl,
        description: 'API Server'
      }
    ],
    paths: {},
    components: {
      schemas: {},
      responses: {
        NotFound: {
          description: 'Resource not found',
          content: {
            'application/json': {
              schema: {
                type: 'object',
                properties: {
                  error: { type: 'string' },
                  message: { type: 'string' }
                }
              }
            }
          }
        },
        ValidationError: {
          description: 'Validation error',
          content: {
            'application/json': {
              schema: {
                type: 'object',
                properties: {
                  error: { type: 'string' },
                  details: { type: 'array', items: { type: 'object' } }
                }
              }
            }
          }
        }
      }
    }
  };

  // Generate paths and schemas for each endpoint
  endpoints.forEach(endpoint => {
    generateEndpointPaths(spec, endpoint);
    generateEndpointSchemas(spec, endpoint);
  });

  return spec;
}

/**
 * Generate paths for a single endpoint
 */
function generateEndpointPaths(spec, endpoint) {
  const { name, path, columns, operations = ['list', 'get', 'create', 'update', 'delete'] } = endpoint;
  const resourceName = name || path.split('/').pop();
  const singularName = resourceName.replace(/s$/, ''); // Simple singularization

  const basePath = path.startsWith('/') ? path : `/${path}`;
  const itemPath = `${basePath}/{id}`;

  spec.paths[basePath] = spec.paths[basePath] || {};
  spec.paths[itemPath] = spec.paths[itemPath] || {};

  // LIST operation - GET /resources
  if (operations.includes('list')) {
    spec.paths[basePath].get = {
      summary: `List all ${resourceName}`,
      tags: [resourceName],
      parameters: [
        {
          name: 'page',
          in: 'query',
          schema: { type: 'integer', default: 1 },
          description: 'Page number'
        },
        {
          name: 'limit',
          in: 'query',
          schema: { type: 'integer', default: 10 },
          description: 'Items per page'
        }
      ],
      responses: {
        '200': {
          description: `List of ${resourceName}`,
          content: {
            'application/json': {
              schema: {
                type: 'object',
                properties: {
                  data: {
                    type: 'array',
                    items: { $ref: `#/components/schemas/${singularName}` }
                  },
                  total: { type: 'integer' },
                  page: { type: 'integer' },
                  limit: { type: 'integer' }
                }
              }
            }
          }
        }
      }
    };
  }

  // CREATE operation - POST /resources
  if (operations.includes('create')) {
    spec.paths[basePath].post = {
      summary: `Create a new ${singularName}`,
      tags: [resourceName],
      requestBody: {
        required: true,
        content: {
          'application/json': {
            schema: { $ref: `#/components/schemas/${singularName}Input` }
          }
        }
      },
      responses: {
        '201': {
          description: `${singularName} created successfully`,
          content: {
            'application/json': {
              schema: { $ref: `#/components/schemas/${singularName}` }
            }
          }
        },
        '400': {
          $ref: '#/components/responses/ValidationError'
        }
      }
    };
  }

  // GET operation - GET /resources/{id}
  if (operations.includes('get')) {
    spec.paths[itemPath].get = {
      summary: `Get a ${singularName} by ID`,
      tags: [resourceName],
      parameters: [
        {
          name: 'id',
          in: 'path',
          required: true,
          schema: { type: 'string' },
          description: `${singularName} ID`
        }
      ],
      responses: {
        '200': {
          description: `${singularName} details`,
          content: {
            'application/json': {
              schema: { $ref: `#/components/schemas/${singularName}` }
            }
          }
        },
        '404': {
          $ref: '#/components/responses/NotFound'
        }
      }
    };
  }

  // UPDATE operation - PUT /resources/{id}
  if (operations.includes('update')) {
    spec.paths[itemPath].put = {
      summary: `Update a ${singularName}`,
      tags: [resourceName],
      parameters: [
        {
          name: 'id',
          in: 'path',
          required: true,
          schema: { type: 'string' },
          description: `${singularName} ID`
        }
      ],
      requestBody: {
        required: true,
        content: {
          'application/json': {
            schema: { $ref: `#/components/schemas/${singularName}Input` }
          }
        }
      },
      responses: {
        '200': {
          description: `${singularName} updated successfully`,
          content: {
            'application/json': {
              schema: { $ref: `#/components/schemas/${singularName}` }
            }
          }
        },
        '400': {
          $ref: '#/components/responses/ValidationError'
        },
        '404': {
          $ref: '#/components/responses/NotFound'
        }
      }
    };
  }

  // DELETE operation - DELETE /resources/{id}
  if (operations.includes('delete')) {
    spec.paths[itemPath].delete = {
      summary: `Delete a ${singularName}`,
      tags: [resourceName],
      parameters: [
        {
          name: 'id',
          in: 'path',
          required: true,
          schema: { type: 'string' },
          description: `${singularName} ID`
        }
      ],
      responses: {
        '204': {
          description: `${singularName} deleted successfully`
        },
        '404': {
          $ref: '#/components/responses/NotFound'
        }
      }
    };
  }
}

/**
 * Generate schemas for a single endpoint
 */
function generateEndpointSchemas(spec, endpoint) {
  const { name, path, columns } = endpoint;
  const resourceName = name || path.split('/').pop();
  const singularName = resourceName.replace(/s$/, '');

  const properties = {};
  const required = [];
  const inputProperties = {};
  const inputRequired = [];

  columns.forEach(column => {
    const {
      name: colName,
      type = 'string',
      required: isRequired = false,
      description = '',
      example,
      enum: enumValues,
      format,
      items,
      readOnly = false
    } = column;

    // Get base type mapping
    let propertyDef = { ...TYPE_MAPPING[type] } || { type: 'string' };

    // Add description if provided
    if (description) {
      propertyDef.description = description;
    }

    // Add example if provided
    if (example !== undefined) {
      propertyDef.example = example;
    }

    // Add enum if provided
    if (enumValues) {
      propertyDef.enum = enumValues;
    }

    // Add format if provided
    if (format) {
      propertyDef.format = format;
    }

    // Handle array items
    if (type === 'array' && items) {
      propertyDef.items = typeof items === 'string'
        ? TYPE_MAPPING[items] || { type: 'string' }
        : items;
    }

    properties[colName] = propertyDef;

    // Add to required array if required
    if (isRequired) {
      required.push(colName);
    }

    // Add to input schema if not readOnly
    if (!readOnly) {
      inputProperties[colName] = { ...propertyDef };
      if (isRequired && colName !== 'id') {
        inputRequired.push(colName);
      }
    }
  });

  // Full schema (with all fields including read-only)
  spec.components.schemas[singularName] = {
    type: 'object',
    properties,
    required: required.length > 0 ? required : undefined
  };

  // Input schema (without read-only fields, used for POST/PUT)
  spec.components.schemas[`${singularName}Input`] = {
    type: 'object',
    properties: inputProperties,
    required: inputRequired.length > 0 ? inputRequired : undefined
  };
}

export default { generateOpenAPI };
