/**
 * Express.js v5 TypeScript CRUD Generator
 * Generates Express.js endpoints from JSON Schema files with example data
 */

import fs from 'fs';
import path from 'path';

/**
 * Load all JSON schemas from a directory
 * @param {string} schemasDir - Path to schemas directory
 * @returns {Array} Array of schema objects with metadata
 */
export function loadSchemas(schemasDir) {
  const files = fs.readdirSync(schemasDir)
    .filter(f => f.endsWith('.schema.json'));

  const schemas = [];

  for (const file of files) {
    const filePath = path.join(schemasDir, file);
    const content = fs.readFileSync(filePath, 'utf-8');
    const schema = JSON.parse(content);

    schemas.push({
      fileName: file,
      schema
    });
  }

  return schemas;
}

/**
 * Generate TypeScript interface from schema
 */
function generateInterface(schema) {
  const { title, properties = {} } = schema;

  const props = Object.entries(properties).map(([key, prop]) => {
    let type = 'any';

    if (prop.$ref) {
      // Reference to another schema
      const refTitle = prop.$ref.replace('.schema.json', '');
      type = refTitle.charAt(0).toUpperCase() + refTitle.slice(1);
    } else if (Array.isArray(prop.type)) {
      // Union type like ["string", "null"]
      type = prop.type.map(t => t === 'null' ? 'null' : mapJsonTypeToTS(t)).join(' | ');
    } else {
      type = mapJsonTypeToTS(prop.type, prop.format);
    }

    const optional = prop.readOnly ? '?' : '';
    return `  ${key}${optional}: ${type};`;
  }).join('\n');

  return `export interface ${title} {\n${props}\n}`;
}

/**
 * Map JSON Schema type to TypeScript type
 */
function mapJsonTypeToTS(jsonType, format) {
  switch (jsonType) {
    case 'string':
      return 'string';
    case 'number':
    case 'integer':
      return 'number';
    case 'boolean':
      return 'boolean';
    case 'array':
      return 'any[]';
    case 'object':
      return 'Record<string, any>';
    default:
      return 'any';
  }
}

/**
 * Generate the main Express app file
 */
function generateAppFile(config) {
  const { title, port = 3000 } = config;

  return `/**
 * ${title}
 * Generated by Express.js CRUD Generator
 */

import express, { Request, Response, NextFunction } from 'express';

const app = express();

// Middleware
app.use(express.json());

// Error handling middleware
app.use((err: Error, req: Request, res: Response, next: NextFunction) => {
  console.error(err.stack);
  res.status(500).json({ error: 'Internal Server Error', message: err.message });
});

// Import routes
import { registerRoutes } from './routes';
registerRoutes(app);

// Health check
app.get('/health', (req: Request, res: Response) => {
  res.json({ status: 'ok', timestamp: new Date().toISOString() });
});

// 404 handler
app.use((req: Request, res: Response) => {
  res.status(404).json({ error: 'Not Found', message: \`Route \${req.method} \${req.path} not found\` });
});

const PORT = process.env.PORT || ${port};

app.listen(PORT, () => {
  console.log(\`Server running on port \${PORT}\`);
});

export default app;
`;
}

/**
 * Generate routes index file
 */
function generateRoutesIndex(schemas) {
  const imports = schemas.map(({ schema }) => {
    const { 'x-camel-plural': camelPlural } = schema;
    return `import { ${camelPlural}Router } from './${camelPlural}';`;
  }).join('\n');

  const registers = schemas.map(({ schema }) => {
    const { 'x-camel-plural': camelPlural } = schema;
    return `  app.use('/${camelPlural}', ${camelPlural}Router);`;
  }).join('\n');

  return `/**
 * Routes Index
 * Generated by Express.js CRUD Generator
 */

import { Express } from 'express';
${imports}

export function registerRoutes(app: Express): void {
${registers}
}
`;
}

/**
 * Generate CRUD router for a single schema
 */
function generateRouter(schema) {
  const {
    title,
    'x-plural': plural,
    'x-camel': camel,
    'x-camel-plural': camelPlural,
    properties = {},
    examples = []
  } = schema;

  // Generate example data from schema examples
  const exampleData = examples.length > 0
    ? JSON.stringify(examples, null, 2)
    : '[]';

  // Get non-readonly properties for create/update
  const writableProps = Object.entries(properties)
    .filter(([_, prop]) => !prop.readOnly)
    .map(([key]) => key);

  return `/**
 * ${plural} Router
 * Generated by Express.js CRUD Generator
 */

import { Router, Request, Response } from 'express';
import { ${title} } from '../types';

const router = Router();

// In-memory data store with example data
let ${camelPlural}: ${title}[] = ${exampleData};

// Helper to generate ID
const generateId = (): string => \`${camel.toLowerCase()}-\${String(${camelPlural}.length + 1).padStart(3, '0')}\`;

/**
 * GET /${camelPlural}
 * List all ${camelPlural} with pagination
 */
router.get('/', (req: Request, res: Response) => {
  const page = parseInt(req.query.page as string) || 1;
  const limit = parseInt(req.query.limit as string) || 10;
  const offset = (page - 1) * limit;

  const paginatedData = ${camelPlural}.slice(offset, offset + limit);

  res.json({
    data: paginatedData,
    total: ${camelPlural}.length,
    page,
    limit
  });
});

/**
 * POST /${camelPlural}
 * Create a new ${camel}
 */
router.post('/', (req: Request, res: Response) => {
  const new${title}: ${title} = {
    id: generateId(),
    ...req.body,
    ${properties.createdAt ? `createdAt: new Date().toISOString(),` : ''}
  };

  ${camelPlural}.push(new${title});
  res.status(201).json(new${title});
});

/**
 * GET /${camelPlural}/:id
 * Get a ${camel} by ID
 */
router.get('/:id', (req: Request, res: Response) => {
  const ${camel} = ${camelPlural}.find(item => item.id === req.params.id);

  if (!${camel}) {
    return res.status(404).json({
      error: 'Not Found',
      message: \`${title} with id '\${req.params.id}' not found\`
    });
  }

  res.json(${camel});
});

/**
 * PUT /${camelPlural}/:id
 * Update a ${camel}
 */
router.put('/:id', (req: Request, res: Response) => {
  const index = ${camelPlural}.findIndex(item => item.id === req.params.id);

  if (index === -1) {
    return res.status(404).json({
      error: 'Not Found',
      message: \`${title} with id '\${req.params.id}' not found\`
    });
  }

  const updated${title}: ${title} = {
    ...${camelPlural}[index],
    ...req.body,
    id: req.params.id // Ensure ID cannot be changed
  };

  ${camelPlural}[index] = updated${title};
  res.json(updated${title});
});

/**
 * DELETE /${camelPlural}/:id
 * Delete a ${camel}
 */
router.delete('/:id', (req: Request, res: Response) => {
  const index = ${camelPlural}.findIndex(item => item.id === req.params.id);

  if (index === -1) {
    return res.status(404).json({
      error: 'Not Found',
      message: \`${title} with id '\${req.params.id}' not found\`
    });
  }

  ${camelPlural}.splice(index, 1);
  res.status(204).send();
});

export { router as ${camelPlural}Router };
`;
}

/**
 * Generate TypeScript types file
 */
function generateTypesFile(schemas) {
  const interfaces = schemas.map(({ schema }) => generateInterface(schema)).join('\n\n');

  return `/**
 * TypeScript Types
 * Generated by Express.js CRUD Generator
 */

${interfaces}
`;
}

/**
 * Generate package.json for the server
 */
function generatePackageJson(config) {
  return {
    name: config.packageName || 'generated-api-server',
    version: config.version || '1.0.0',
    description: config.description || 'Generated Express.js API Server',
    main: 'dist/app.js',
    type: 'module',
    scripts: {
      build: 'tsc',
      start: 'node dist/app.js',
      dev: 'tsx watch src/app.ts'
    },
    dependencies: {
      express: '^5.0.0'
    },
    devDependencies: {
      '@types/express': '^5.0.0',
      '@types/node': '^20.0.0',
      typescript: '^5.0.0',
      tsx: '^4.0.0'
    }
  };
}

/**
 * Generate tsconfig.json for the server
 */
function generateTsConfig() {
  return {
    compilerOptions: {
      target: 'ES2022',
      module: 'NodeNext',
      moduleResolution: 'NodeNext',
      esModuleInterop: true,
      strict: true,
      skipLibCheck: true,
      outDir: './dist',
      rootDir: './src',
      declaration: true
    },
    include: ['src/**/*'],
    exclude: ['node_modules', 'dist']
  };
}

/**
 * Generate Express.js server from configuration and schemas
 * @param {Object} config - Configuration object
 * @returns {Object} Generated files
 */
export async function generateExpress(config) {
  const {
    title = 'Generated API',
    version = '1.0.0',
    description = 'API generated by Express.js CRUD Generator',
    port = 3000,
    schemasDir
  } = config;

  if (!schemasDir) {
    throw new Error('schemasDir is required in configuration');
  }

  // Load all schemas
  const schemaFiles = loadSchemas(schemasDir);

  const files = {};

  // Generate app.ts
  files['src/app.ts'] = generateAppFile(config);

  // Generate types
  files['src/types/index.ts'] = generateTypesFile(schemaFiles);

  // Generate routes index
  files['src/routes/index.ts'] = generateRoutesIndex(schemaFiles);

  // Generate individual routers
  for (const { schema } of schemaFiles) {
    const camelPlural = schema['x-camel-plural'];
    if (camelPlural) {
      files[`src/routes/${camelPlural}.ts`] = generateRouter(schema);
    }
  }

  // Generate package.json
  files['package.json'] = JSON.stringify(generatePackageJson(config), null, 2);

  // Generate tsconfig.json
  files['tsconfig.json'] = JSON.stringify(generateTsConfig(), null, 2);

  return files;
}

export default { generateExpress, loadSchemas };
