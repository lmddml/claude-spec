/**
 * Express.js v5 TypeScript CRUD Generator
 * Generates Express.js endpoints from JSON Schema files with example data
 *
 * Architecture: Model -> Service -> Routes
 * - Model: Data layer (future: PostgreSQL)
 * - Service: Business logic (future: complex operations)
 * - Routes: Express endpoints (future: Zod validation)
 */

import fs from 'fs';
import path from 'path';

/**
 * Load all JSON schemas from a directory
 * @param {string} schemasDir - Path to schemas directory
 * @returns {Array} Array of schema objects with metadata
 */
export function loadSchemas(schemasDir) {
  const files = fs.readdirSync(schemasDir)
    .filter(f => f.endsWith('.schema.json'));

  const schemas = [];

  for (const file of files) {
    const filePath = path.join(schemasDir, file);
    const content = fs.readFileSync(filePath, 'utf-8');
    const schema = JSON.parse(content);

    schemas.push({
      fileName: file,
      schema
    });
  }

  return schemas;
}

/**
 * Generate TypeScript interface from schema
 */
function generateInterface(schema) {
  const { title, properties = {} } = schema;

  const props = Object.entries(properties).map(([key, prop]) => {
    let type = 'any';

    if (prop.$ref) {
      // Reference to another schema
      const refTitle = prop.$ref.replace('.schema.json', '');
      type = refTitle.charAt(0).toUpperCase() + refTitle.slice(1);
    } else if (Array.isArray(prop.type)) {
      // Union type like ["string", "null"]
      type = prop.type.map(t => t === 'null' ? 'null' : mapJsonTypeToTS(t)).join(' | ');
    } else {
      type = mapJsonTypeToTS(prop.type, prop.format);
    }

    const optional = prop.readOnly ? '?' : '';
    return `  ${key}${optional}: ${type};`;
  }).join('\n');

  return `export interface ${title} {\n${props}\n}`;
}

/**
 * Map JSON Schema type to TypeScript type
 */
function mapJsonTypeToTS(jsonType, format) {
  switch (jsonType) {
    case 'string':
      return 'string';
    case 'number':
    case 'integer':
      return 'number';
    case 'boolean':
      return 'boolean';
    case 'array':
      return 'any[]';
    case 'object':
      return 'Record<string, any>';
    default:
      return 'any';
  }
}

/**
 * Generate the main Express app file
 */
function generateAppFile(config) {
  const { title, port = 3000 } = config;

  return `/**
 * ${title}
 * Generated by Express.js CRUD Generator
 */

import express, { Request, Response, NextFunction } from 'express';

const app = express();

// Middleware
app.use(express.json());

// Error handling middleware
app.use((err: Error, req: Request, res: Response, next: NextFunction) => {
  console.error(err.stack);
  res.status(500).json({ error: 'Internal Server Error', message: err.message });
});

// Import routes
import { registerRoutes } from './routes';
registerRoutes(app);

// Health check
app.get('/health', (req: Request, res: Response) => {
  res.json({ status: 'ok', timestamp: new Date().toISOString() });
});

// 404 handler
app.use((req: Request, res: Response) => {
  res.status(404).json({ error: 'Not Found', message: \`Route \${req.method} \${req.path} not found\` });
});

const PORT = process.env.PORT || ${port};

app.listen(PORT, () => {
  console.log(\`Server running on port \${PORT}\`);
});

export default app;
`;
}

/**
 * Generate routes index file
 */
function generateRoutesIndex(schemas) {
  const imports = schemas.map(({ schema }) => {
    const { 'x-camel': camel, 'x-camel-plural': camelPlural } = schema;
    return `import { ${camel}Routes } from './${camel}/${camel}Routes';`;
  }).join('\n');

  const registers = schemas.map(({ schema }) => {
    const { 'x-camel': camel, 'x-camel-plural': camelPlural } = schema;
    return `  app.use('/${camelPlural}', ${camel}Routes);`;
  }).join('\n');

  return `/**
 * Routes Index
 * Generated by Express.js CRUD Generator
 */

import { Express } from 'express';
${imports}

export function registerRoutes(app: Express): void {
${registers}
}
`;
}

/**
 * Generate Model file for a schema
 */
function generateModel(schema) {
  const {
    title,
    'x-camel': camel,
    'x-camel-plural': camelPlural,
    examples = []
  } = schema;

  const exampleData = examples.length > 0
    ? JSON.stringify(examples, null, 2)
    : '[]';

  return `/**
 * ${title} Model
 * Data layer - handles storage and retrieval
 * Future: PostgreSQL integration
 */

import { ${title} } from '../../types';

// In-memory data store with example data
let ${camelPlural}: ${title}[] = ${exampleData};

// Helper to generate ID
const generateId = (): string => \`${camel.toLowerCase()}-\${String(${camelPlural}.length + 1).padStart(3, '0')}\`;

/**
 * Get all ${camelPlural}
 */
export function findAll(): ${title}[] {
  return ${camelPlural};
}

/**
 * Get ${camel} by ID
 */
export function findById(id: string): ${title} | undefined {
  return ${camelPlural}.find(item => item.id === id);
}

/**
 * Create a new ${camel}
 */
export function create(data: Partial<${title}>): ${title} {
  const new${title}: ${title} = {
    id: generateId(),
    ...data,
  } as ${title};

  ${camelPlural}.push(new${title});
  return new${title};
}

/**
 * Update a ${camel}
 */
export function update(id: string, data: Partial<${title}>): ${title} | undefined {
  const index = ${camelPlural}.findIndex(item => item.id === id);

  if (index === -1) {
    return undefined;
  }

  const updated${title}: ${title} = {
    ...${camelPlural}[index],
    ...data,
    id // Ensure ID cannot be changed
  };

  ${camelPlural}[index] = updated${title};
  return updated${title};
}

/**
 * Delete a ${camel}
 */
export function remove(id: string): boolean {
  const index = ${camelPlural}.findIndex(item => item.id === id);

  if (index === -1) {
    return false;
  }

  ${camelPlural}.splice(index, 1);
  return true;
}

/**
 * Count total ${camelPlural}
 */
export function count(): number {
  return ${camelPlural}.length;
}
`;
}

/**
 * Generate Service file for a schema
 */
function generateService(schema) {
  const {
    title,
    'x-camel': camel,
    'x-camel-plural': camelPlural
  } = schema;

  return `/**
 * ${title} Service
 * Business logic layer - connects Model with Routes
 * Future: Complex business logic, cross-entity operations
 */

import { ${title} } from '../../types';
import * as ${camel}Model from './${camel}Model';

export interface PaginatedResult<T> {
  data: T[];
  total: number;
  page: number;
  limit: number;
}

/**
 * List ${camelPlural} with pagination
 */
export function list(page: number = 1, limit: number = 10): PaginatedResult<${title}> {
  const all${title}s = ${camel}Model.findAll();
  const offset = (page - 1) * limit;
  const paginatedData = all${title}s.slice(offset, offset + limit);

  return {
    data: paginatedData,
    total: ${camel}Model.count(),
    page,
    limit
  };
}

/**
 * Get ${camel} by ID
 */
export function getById(id: string): ${title} | undefined {
  return ${camel}Model.findById(id);
}

/**
 * Create a new ${camel}
 */
export function create(data: Partial<${title}>): ${title} {
  // Future: Add business logic validation here
  return ${camel}Model.create(data);
}

/**
 * Update a ${camel}
 */
export function update(id: string, data: Partial<${title}>): ${title} | undefined {
  // Future: Add business logic validation here
  return ${camel}Model.update(id, data);
}

/**
 * Delete a ${camel}
 */
export function remove(id: string): boolean {
  // Future: Add cascade delete logic, check dependencies
  return ${camel}Model.remove(id);
}
`;
}

/**
 * Generate Routes file for a schema
 */
function generateRoutes(schema) {
  const {
    title,
    'x-camel': camel,
    'x-camel-plural': camelPlural
  } = schema;

  return `/**
 * ${title} Routes
 * Express endpoints - handles HTTP requests
 * Future: Zod validation
 */

import { Router, Request, Response } from 'express';
import * as ${camel}Service from './${camel}Service';

const router = Router();

/**
 * GET /${camelPlural}
 * List all ${camelPlural} with pagination
 */
router.get('/', (req: Request, res: Response) => {
  const page = parseInt(req.query.page as string) || 1;
  const limit = parseInt(req.query.limit as string) || 10;

  const result = ${camel}Service.list(page, limit);
  res.json(result);
});

/**
 * POST /${camelPlural}
 * Create a new ${camel}
 */
router.post('/', (req: Request, res: Response) => {
  // Future: Add Zod validation here
  const new${title} = ${camel}Service.create(req.body);
  res.status(201).json(new${title});
});

/**
 * GET /${camelPlural}/:id
 * Get a ${camel} by ID
 */
router.get('/:id', (req: Request, res: Response) => {
  const ${camel} = ${camel}Service.getById(req.params.id);

  if (!${camel}) {
    return res.status(404).json({
      error: 'Not Found',
      message: \`${title} with id '\${req.params.id}' not found\`
    });
  }

  res.json(${camel});
});

/**
 * PUT /${camelPlural}/:id
 * Update a ${camel}
 */
router.put('/:id', (req: Request, res: Response) => {
  // Future: Add Zod validation here
  const updated${title} = ${camel}Service.update(req.params.id, req.body);

  if (!updated${title}) {
    return res.status(404).json({
      error: 'Not Found',
      message: \`${title} with id '\${req.params.id}' not found\`
    });
  }

  res.json(updated${title});
});

/**
 * DELETE /${camelPlural}/:id
 * Delete a ${camel}
 */
router.delete('/:id', (req: Request, res: Response) => {
  const deleted = ${camel}Service.remove(req.params.id);

  if (!deleted) {
    return res.status(404).json({
      error: 'Not Found',
      message: \`${title} with id '\${req.params.id}' not found\`
    });
  }

  res.status(204).send();
});

export { router as ${camel}Routes };
`;
}

/**
 * Generate TypeScript types file
 */
function generateTypesFile(schemas) {
  const interfaces = schemas.map(({ schema }) => generateInterface(schema)).join('\n\n');

  return `/**
 * TypeScript Types
 * Generated by Express.js CRUD Generator
 */

${interfaces}
`;
}

/**
 * Generate package.json for the server
 */
function generatePackageJson(config) {
  return {
    name: config.packageName || 'generated-api-server',
    version: config.version || '1.0.0',
    description: config.description || 'Generated Express.js API Server',
    main: 'dist/app.js',
    type: 'module',
    scripts: {
      build: 'tsc',
      start: 'node dist/app.js',
      dev: 'tsx watch src/app.ts'
    },
    dependencies: {
      express: '^5.0.0'
    },
    devDependencies: {
      '@types/express': '^5.0.0',
      '@types/node': '^20.0.0',
      typescript: '^5.0.0',
      tsx: '^4.0.0'
    }
  };
}

/**
 * Generate tsconfig.json for the server
 */
function generateTsConfig() {
  return {
    compilerOptions: {
      target: 'ES2022',
      module: 'NodeNext',
      moduleResolution: 'NodeNext',
      esModuleInterop: true,
      strict: true,
      skipLibCheck: true,
      outDir: './dist',
      rootDir: './src',
      declaration: true
    },
    include: ['src/**/*'],
    exclude: ['node_modules', 'dist']
  };
}

/**
 * Generate Express.js server from configuration and schemas
 * @param {Object} config - Configuration object
 * @returns {Object} Generated files
 */
export async function generateExpress(config) {
  const {
    title = 'Generated API',
    version = '1.0.0',
    description = 'API generated by Express.js CRUD Generator',
    port = 3000,
    schemasDir
  } = config;

  if (!schemasDir) {
    throw new Error('schemasDir is required in configuration');
  }

  // Load all schemas
  const schemaFiles = loadSchemas(schemasDir);

  const files = {};

  // Generate app.ts
  files['src/app.ts'] = generateAppFile(config);

  // Generate types
  files['src/types/index.ts'] = generateTypesFile(schemaFiles);

  // Generate routes index
  files['src/routes/index.ts'] = generateRoutesIndex(schemaFiles);

  // Generate Model, Service, Routes for each entity
  for (const { schema } of schemaFiles) {
    const camel = schema['x-camel'];
    if (camel) {
      files[`src/routes/${camel}/${camel}Model.ts`] = generateModel(schema);
      files[`src/routes/${camel}/${camel}Service.ts`] = generateService(schema);
      files[`src/routes/${camel}/${camel}Routes.ts`] = generateRoutes(schema);
    }
  }

  // Generate package.json
  files['package.json'] = JSON.stringify(generatePackageJson(config), null, 2);

  // Generate tsconfig.json
  files['tsconfig.json'] = JSON.stringify(generateTsConfig(), null, 2);

  return files;
}

export default { generateExpress, loadSchemas };
