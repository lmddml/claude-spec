/**
 * Express.js v5 TypeScript CRUD Generator
 * Generates Express.js endpoints from JSON Schema files with example data
 *
 * Architecture: Model -> Service -> Routes
 * - Model: Data layer (future: PostgreSQL)
 * - Service: Business logic (future: complex operations)
 * - Routes: Express endpoints (future: Zod validation)
 */

import fs from 'fs';
import path from 'path';

/**
 * Load all JSON schemas from a directory
 * @param {string} schemasDir - Path to schemas directory
 * @returns {Array} Array of schema objects with metadata
 */
export function loadSchemas(schemasDir) {
  const files = fs.readdirSync(schemasDir)
    .filter(f => f.endsWith('.schema.json'));

  const schemas = [];

  for (const file of files) {
    const filePath = path.join(schemasDir, file);
    const content = fs.readFileSync(filePath, 'utf-8');
    const schema = JSON.parse(content);

    schemas.push({
      fileName: file,
      schema
    });
  }

  return schemas;
}

/**
 * Generate TypeScript interface from schema
 */
function generateInterface(schema) {
  const { title, properties = {}, required = [] } = schema;

  const baseProps = [];
  const populatedProps = [];

  Object.entries(properties).forEach(([key, prop]) => {
    let type = 'any';

    if (prop.$ref) {
      // Reference to another schema
      const refTitle = prop.$ref.replace('.schema.json', '');
      type = refTitle.charAt(0).toUpperCase() + refTitle.slice(1);

      // Add to populated props
      const isRequired = required.includes(key);
      const optional = (!isRequired || prop.readOnly) ? '?' : '';
      populatedProps.push(`  ${key}${optional}: ${type};`);
    } else {
      if (Array.isArray(prop.type)) {
        // Union type like ["string", "null"]
        type = prop.type.map(t => t === 'null' ? 'null' : mapJsonTypeToTS(t)).join(' | ');
      } else {
        type = mapJsonTypeToTS(prop.type, prop.format);
      }

      const isRequired = required.includes(key);
      const optional = (!isRequired || prop.readOnly) ? '?' : '';
      baseProps.push(`  ${key}${optional}: ${type};`);
    }
  });

  const baseInterface = `export interface ${title} {\n${baseProps.join('\n')}\n}`;
  const populatedInterface = `export interface ${title}Populated extends ${title} {\n${populatedProps.join('\n')}\n}`;

  return `${baseInterface}\n\n${populatedInterface}`;
}

/**
 * Map JSON Schema type to TypeScript type
 */
function mapJsonTypeToTS(jsonType, format) {
  switch (jsonType) {
    case 'string':
      return 'string';
    case 'number':
    case 'integer':
      return 'number';
    case 'boolean':
      return 'boolean';
    case 'array':
      return 'any[]';
    case 'object':
      return 'Record<string, any>';
    default:
      return 'any';
  }
}

/**
 * Generate common validation schemas
 */
function generateCommonValidation() {
  return `/**
 * Common Validation Schemas
 * Generated by Express.js CRUD Generator
 */

import { z } from 'zod';

export const paginationSchema = z.object({
  page: z.coerce.number().int().positive().default(1),
  limit: z.coerce.number().int().positive().default(10),
});

export const idParamsSchema = z.object({
  id: z.string(),
});
`;
}

/**
 * Generate Zod schema from JSON Schema
 */
function generateZodSchema(schema) {
  const { title, properties = {}, required = [] } = schema;
  const camel = schema['x-camel'];

  const zodProps = Object.entries(properties).map(([key, prop]) => {
    // Skip properties with $ref (Foreign Key Pattern: excluded from input)
    if (prop.$ref) {
      return null;
    }

    let validator = 'z.any()';

    if (Array.isArray(prop.type)) {
      // Handle union types like ["string", "null"]
      const types = prop.type.map(t => {
        if (t === 'null') return 'z.null()';
        return mapJsonTypeToZod(t, prop.format);
      });
      validator = `z.union([${types.join(', ')}])`;
    } else {
      validator = mapJsonTypeToZod(prop.type, prop.format);
    }

    // Handle optional
    const isRequired = required.includes(key);
    const isReadOnly = prop.readOnly;

    if (!isRequired || isReadOnly) {
      validator += '.optional()';
    }

    return `  ${key}: ${validator},`;
  }).filter(Boolean).join('\n');

  return `/**
 * ${title} Validation Schema
 * Generated by Express.js CRUD Generator
 */

import { z } from 'zod';

export const ${camel}Schema = z.object({
${zodProps}
});
`;
}

/**
 * Map JSON Schema type to Zod validator
 */
function mapJsonTypeToZod(jsonType, format) {
  switch (jsonType) {
    case 'string':
      if (format === 'email') return 'z.string().email()';
      if (format === 'uuid') return 'z.string().uuid()';
      if (format === 'date-time') return 'z.string().datetime()';
      return 'z.string()';
    case 'number':
    case 'integer':
      return 'z.number()';
    case 'boolean':
      return 'z.boolean()';
    case 'array':
      return 'z.array(z.any())'; // Complex array types might need recursion
    case 'object':
      return 'z.record(z.any())';
    default:
      return 'z.any()';
  }
}

/**
 * Generate the main Express app file
 */
function generateAppFile(config) {
  const { title, port = 3000 } = config;

  return `/**
 * ${title}
 * Generated by Express.js CRUD Generator
 */

import express, { type Request, type Response, type NextFunction } from 'express';

const app = express();

// Middleware
app.use(express.json());

// Error handling middleware
app.use((err: Error, req: Request, res: Response, next: NextFunction) => {
  console.error(err.stack);
  res.status(500).json({ error: 'Internal Server Error', message: err.message });
});

// Import routes
import { registerRoutes } from './routes/index.ts';
registerRoutes(app);

// Health check
app.get('/health', (req: Request, res: Response) => {
  res.json({ status: 'ok', timestamp: new Date().toISOString() });
});

// 404 handler
app.use((req: Request, res: Response) => {
  res.status(404).json({ error: 'Not Found', message: \`Route \${req.method} \${req.path} not found\` });
});

const PORT = process.env.PORT || ${port};

app.listen(PORT, () => {
  console.log(\`Server running on port \${PORT}\`);
});

export default app;
`;
}

/**
 * Generate routes index file
 */
function generateRoutesIndex(schemas) {
  const imports = schemas.map(({ schema }) => {
    const { 'x-camel': camel, 'x-camel-plural': camelPlural } = schema;
    return `import { ${camel}Routes } from './${camel}/${camel}Routes.ts';`;
  }).join('\n');

  const registers = schemas.map(({ schema }) => {
    const { 'x-camel': camel, 'x-camel-plural': camelPlural } = schema;
    return `  app.use('/${camelPlural}', ${camel}Routes);`;
  }).join('\n');

  return `/**
 * Routes Index
 * Generated by Express.js CRUD Generator
 */

import type { Express } from 'express';
${imports}

export function registerRoutes(app: Express): void {
${registers}
}
`;
}

/**
 * Generate Model file for a schema
 */
function generateModel(schema) {
  const {
    title,
    'x-camel': camel,
    'x-camel-plural': camelPlural,
    examples = []
  } = schema;

  const exampleData = examples.length > 0
    ? JSON.stringify(examples, null, 2)
    : '[]';

  return `/**
 * ${title} Model
 * Data layer - handles storage and retrieval
 * Future: PostgreSQL integration
 */

import type { ${title}, ${title}Populated } from '../../types/index.ts';

// In-memory data store with example data
let ${camelPlural}: ${title}Populated[] = ${exampleData};

// Helper to generate ID
const generateId = (): string => \`${camel.toLowerCase()}-\${String(${camelPlural}.length + 1).padStart(3, '0')}\`;

/**
 * Get all ${camelPlural}
 */
export function findAll(): ${title}Populated[] {
  return ${camelPlural};
}

/**
 * Get ${camel} by ID
 */
export function findById(id: string): ${title}Populated | undefined {
  return ${camelPlural}.find(item => item.id === id);
}

/**
 * Create a new ${camel}
 */
export function create(data: Partial<${title}>): ${title}Populated {
  const new${title}: ${title}Populated = {
    id: generateId(),
    ...data,
  } as ${title}Populated;

  ${camelPlural}.push(new${title});
  return new${title};
}

/**
 * Update a ${camel}
 */
export function update(id: string, data: Partial<${title}>): ${title}Populated | undefined {
  const index = ${camelPlural}.findIndex(item => item.id === id);

  if (index === -1) {
    return undefined;
  }

  const updated${title}: ${title}Populated = {
    ...${camelPlural}[index],
    ...data,
    id // Ensure ID cannot be changed
  } as ${title}Populated;

  ${camelPlural}[index] = updated${title};
  return updated${title};
}

/**
 * Delete a ${camel}
 */
export function remove(id: string): boolean {
  const index = ${camelPlural}.findIndex(item => item.id === id);

  if (index === -1) {
    return false;
  }

  ${camelPlural}.splice(index, 1);
  return true;
}

/**
 * Count total ${camelPlural}
 */
export function count(): number {
  return ${camelPlural}.length;
}
`;
}

/**
 * Generate Service file for a schema
 */
function generateService(schema) {
  const {
    title,
    'x-camel': camel,
    'x-camel-plural': camelPlural
  } = schema;

  return `/**
 * ${title} Service
 * Business logic layer - connects Model with Routes
 * Future: Complex business logic, cross-entity operations
 */

import type { ${title}, ${title}Populated } from '../../types/index.ts';
import * as ${camel}Model from './${camel}Model.ts';

export interface PaginatedResult<T> {
  data: T[];
  total: number;
  page: number;
  limit: number;
}

/**
 * List ${camelPlural} with pagination
 */
export function list(page: number, limit: number): PaginatedResult<${title}Populated> {
  const all${title}s = ${camel}Model.findAll();
  const offset = (page - 1) * limit;
  const paginatedData = all${title}s.slice(offset, offset + limit);

  return {
    data: paginatedData,
    total: ${camel}Model.count(),
    page,
    limit
  };
}

/**
 * Get ${camel} by ID
 */
export function getById(id: string): ${title}Populated | undefined {
  return ${camel}Model.findById(id);
}

/**
 * Create a new ${camel}
 */
export function create(data: Partial<${title}>): ${title}Populated {
  // Future: Add business logic validation here
  return ${camel}Model.create(data);
}

/**
 * Update a ${camel}
 */
export function update(id: string, data: Partial<${title}>): ${title}Populated | undefined {
  // Future: Add business logic validation here
  return ${camel}Model.update(id, data);
}

/**
 * Delete a ${camel}
 */
export function remove(id: string): boolean {
  // Future: Add cascade delete logic, check dependencies
  return ${camel}Model.remove(id);
}
`;
}

/**
 * Generate Routes file for a schema
 */
function generateRoutes(schema) {
  const {
    title,
    'x-camel': camel,
    'x-camel-plural': camelPlural
  } = schema;

  return `/**
 * ${title} Routes
 * Express endpoints - handles HTTP requests
 * Zod validation enabled
 */

import { Router, type Request, type Response } from 'express';
import { z } from 'zod';
import * as ${camel}Service from './${camel}Service.ts';
import { ${camel}Schema } from './${camel}Schema.ts';
import { paginationSchema, idParamsSchema } from '../../common/validation.ts';

const router = Router();

/**
 * GET /${camelPlural}
 * List all ${camelPlural} with pagination
 */
router.get('/', (req: Request, res: Response) => {
  try {
    const { page, limit } = paginationSchema.parse(req.query);
    const result = ${camel}Service.list(page, limit);
    res.json(result);
  } catch (error) {
    if (error instanceof z.ZodError) {
      res.status(400).json({ error: 'Validation Error', details: error.errors });
    } else {
      throw error;
    }
  }
});

/**
 * POST /${camelPlural}
 * Create a new ${camel}
 */
router.post('/', (req: Request, res: Response) => {
  try {
    const validatedData = ${camel}Schema.parse(req.body);
    const new${title} = ${camel}Service.create(validatedData);
    res.status(201).json(new${title});
  } catch (error) {
    if (error instanceof z.ZodError) {
      res.status(400).json({ error: 'Validation Error', details: error.errors });
    } else {
      throw error;
    }
  }
});

/**
 * GET /${camelPlural}/:id
 * Get a ${camel} by ID
 */
router.get('/:id', (req: Request, res: Response) => {
  try {
    const { id } = idParamsSchema.parse(req.params);
    const ${camel} = ${camel}Service.getById(id);

    if (!${camel}) {
      return res.status(404).json({
        error: 'Not Found',
        message: \`${title} with id '\${id}' not found\`
      });
    }

    res.json(${camel});
  } catch (error) {
    if (error instanceof z.ZodError) {
      res.status(400).json({ error: 'Validation Error', details: error.errors });
    } else {
      throw error;
    }
  }
});

/**
 * PUT /${camelPlural}/:id
 * Update a ${camel}
 */
router.put('/:id', (req: Request, res: Response) => {
  try {
    const { id } = idParamsSchema.parse(req.params);
    const validatedData = ${camel}Schema.partial().parse(req.body);
    
    const updated${title} = ${camel}Service.update(id, validatedData);

    if (!updated${title}) {
      return res.status(404).json({
        error: 'Not Found',
        message: \`${title} with id '\${id}' not found\`
      });
    }

    res.json(updated${title});
  } catch (error) {
    if (error instanceof z.ZodError) {
      res.status(400).json({ error: 'Validation Error', details: error.errors });
    } else {
      throw error;
    }
  }
});

/**
 * DELETE /${camelPlural}/:id
 * Delete a ${camel}
 */
router.delete('/:id', (req: Request, res: Response) => {
  try {
    const { id } = idParamsSchema.parse(req.params);
    const deleted = ${camel}Service.remove(id);

    if (!deleted) {
      return res.status(404).json({
        error: 'Not Found',
        message: \`${title} with id '\${id}' not found\`
      });
    }

    res.status(204).send();
  } catch (error) {
    if (error instanceof z.ZodError) {
      res.status(400).json({ error: 'Validation Error', details: error.errors });
    } else {
      throw error;
    }
  }
});

export { router as ${camel}Routes };
`;
}

/**
 * Generate TypeScript types file
 */
function generateTypesFile(schemas) {
  const interfaces = schemas.map(({ schema }) => generateInterface(schema)).join('\n\n');

  return `/**
 * TypeScript Types
 * Generated by Express.js CRUD Generator
 */

${interfaces}
`;
}

/**
 * Generate package.json for the server
 */
function generatePackageJson(config) {
  return {
    name: config.packageName || 'generated-api-server',
    version: config.version || '1.0.0',
    description: config.description || 'Generated Express.js API Server',
    main: 'dist/app.js',
    type: 'module',
    engines: {
      "node": ">=25"
    },
    scripts: {
      build: 'tsc',
      start: 'node src/app.ts',
      dev: 'node --watch src/app.ts',
      typecheck: 'tsc --noEmit'
    },
    dependencies: {
      express: '^5.0.0',
      zod: '^3.0.0'
    },
    devDependencies: {
      '@types/express': '^5.0.0',
      '@types/node': '^20.0.0',
      typescript: '^5.7.0'
    }
  };
}

/**
 * Generate tsconfig.json for the server
 */
function generateTsConfig() {
  return {
    compilerOptions: {
      target: 'esnext',
      module: 'nodenext',
      moduleResolution: 'nodenext',
      esModuleInterop: true,
      strict: true,
      skipLibCheck: true,
      outDir: './dist',
      rootDir: './src',
      declaration: true,
      declarationMap: true,
      sourceMap: true,
      noUncheckedIndexedAccess: true,
      exactOptionalPropertyTypes: false,
      jsx: "react-jsx",
      verbatimModuleSyntax: true,
      isolatedModules: true,
      noUncheckedSideEffectImports: true,
      moduleDetection: "force",
      allowImportingTsExtensions: true,
      noEmit: true,
      types: [],
      lib: ["esnext"]
    },
    include: ['src/**/*'],
    exclude: ['node_modules', 'dist']
  };
}

/**
 * Generate Express.js server from configuration and schemas
 * @param {Object} config - Configuration object
 * @returns {Object} Generated files
 */
export async function generateExpress(config) {
  const {
    title = 'Generated API',
    version = '1.0.0',
    description = 'API generated by Express.js CRUD Generator',
    port = 3000,
    schemasDir
  } = config;

  if (!schemasDir) {
    throw new Error('schemasDir is required in configuration');
  }

  // Load all schemas
  const schemaFiles = loadSchemas(schemasDir);

  const files = {};

  // Generate app.ts
  files['src/app.ts'] = generateAppFile(config);

  // Generate types
  files['src/types/index.ts'] = generateTypesFile(schemaFiles);

  // Generate common validation
  files['src/common/validation.ts'] = generateCommonValidation();

  // Generate routes index
  files['src/routes/index.ts'] = generateRoutesIndex(schemaFiles);

  // Generate Model, Service, Routes, and Schema for each entity
  for (const { schema } of schemaFiles) {
    const camel = schema['x-camel'];
    if (camel) {
      files[`src/routes/${camel}/${camel}Model.ts`] = generateModel(schema);
      files[`src/routes/${camel}/${camel}Service.ts`] = generateService(schema);
      files[`src/routes/${camel}/${camel}Routes.ts`] = generateRoutes(schema);
      files[`src/routes/${camel}/${camel}Schema.ts`] = generateZodSchema(schema);
    }
  }

  // Generate package.json and tsconfig.json
  files['package.json'] = JSON.stringify(generatePackageJson(config), null, 2);
  files['tsconfig.json'] = JSON.stringify(generateTsConfig(), null, 2);

  return files;
}

export default { generateExpress, loadSchemas };
